# Knowledge Base for categorizer
Generated at: 2025-03-06 22:00:00


## Root Directory

    üìÑ next-env.d.ts
    Path: ./next-env.d.ts
    --------------------------------------------------
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


    --------------------------------------------------

    üìÑ next.config.ts
    Path: ./next.config.ts
    --------------------------------------------------
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


    --------------------------------------------------

    üìÑ tailwind.config.ts
    Path: ./tailwind.config.ts
    --------------------------------------------------
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
    "*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};


    --------------------------------------------------

    üìÑ tsconfig.json
    Path: ./tsconfig.json
    --------------------------------------------------
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


    --------------------------------------------------

    üìÅ app/

        üìÑ layout.tsx
        Path: app/layout.tsx
        --------------------------------------------------
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


        --------------------------------------------------

        üìÑ page.tsx
        Path: app/page.tsx
        --------------------------------------------------
"use client";
import { CategoryButton } from "./components/LinkButton";
import { Marquee } from "./components/MarqueeComponent/MarqueeComponent";
import { Badge } from "./components/BadgeComponent/BadgeComponent";
import React from "react";
import { TitleComponent } from "./components/TitleComponent/TtitleComponent";

export default function Home() {
  const marqueeOptions = [
    "Organize",
    "Great Visuals",
    "Categorize",
    "Connect & Discover",
    "Empower Insights",
    "Simplify Data",
    "Intelligent Mapping",
  ];
  return (
    <main className="container mx-auto p-4 min-h-screen flex flex-col items-center justify-center bg-yellow-100">
      <TitleComponent title="Let's Organize It" variant="red"></TitleComponent>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        <CategoryButton href="/ocr" label="OCR Image" color="bg-blue-400" />
        <CategoryButton
          href="/fill-form"
          label="Fill Form"
          color="bg-blue-400"
        />
        <CategoryButton
          href="/upload-files"
          label="Upload multiple files"
          color="bg-blue-400"
        />
        <CategoryButton
          href="/just-images"
          label="Just Images"
          color="bg-blue-400"
        />
        <CategoryButton href="/videos" label="Video" color="bg-blue-400" />
        <CategoryButton
          href="/visualizer"
          label="Visualization"
          color="bg-blue-400"
        />
        <CategoryButton
          href="/ask-something"
          label="Preguntar"
          color="bg-blue-400"
        />
        <CategoryButton
          href="/pending"
          label="Pendientes"
          color="bg-blue-400"
        />
      </div>
      <Marquee className="mb-8 mt-12" speed="slow">
        <div className="flex items-center gap-4 px-4">
          {marqueeOptions.map((option, idx) => (
            <React.Fragment key={idx}>
              {idx % 2 === 0 ? (
                <Badge variant="outline" className="text-base">
                  {option}
                </Badge>
              ) : (
                <span className="text-base">{option}</span>
              )}
              <span className="text-lg font-bold">|</span>
            </React.Fragment>
          ))}
        </div>
      </Marquee>
    </main>
  );
}


        --------------------------------------------------

        üìÅ ask-something/

            üìÑ page.tsx
            Path: app\ask-something/page.tsx
            --------------------------------------------------
"use client";

import React, { useState, useEffect, useRef } from "react";
import { useDropzone } from "react-dropzone"; // Si lo requieres en alg√∫n otro flujo
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { BrutalInput } from "../components/InputComponent/InputComponent";
import BrutalDropDown from "../components/DropDownComponent/DropdownComponent";
import BrutalCheckbox from "../components/CheckBoxComponent/CheckBoxComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";

interface ChatMessage {
  role: "user" | "assistant" | "system";
  content: string;
}

export default function RagBrutalistChat() {
  // Estados para la conversaci√≥n
  const [messages, setMessages] = useState<ChatMessage[]>([
    {
      role: "system",
      content: "¬°Bienvenido! Configura tus opciones y haz una pregunta.",
    },
  ]);
  const [userInput, setUserInput] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  // Estados de configuraci√≥n RAG
  const [model, setModel] = useState("gpt-3.5");
  const [temperature, setTemperature] = useState(0.7);
  const [retrievalMethod, setRetrievalMethod] = useState("vector");
  const [tools, setTools] = useState<string[]>([]);
  const [topK, setTopK] = useState(3);
  const [chunkSize, setChunkSize] = useState(512);

  // Referencia para scroll autom√°tico en el chat
  const messagesEndRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  // Funci√≥n para enviar mensaje al backend
  const handleSend = async () => {
    if (!userInput.trim()) return;
    setIsLoading(true);
    const newUserMessage: ChatMessage = { role: "user", content: userInput };
    const updatedMessages = [...messages, newUserMessage];
    setMessages(updatedMessages);
    try {
      const response = await fetch("/api/ragChat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: updatedMessages,
          config: {
            model,
            temperature,
            retrievalMethod,
            tools,
            topK,
            chunkSize,
          },
        }),
      });
      if (!response.ok) throw new Error("Error en la llamada a /api/ragChat");
      const data = await response.json();
      const assistantMessage: ChatMessage = {
        role: "assistant",
        content: data.assistantMessage || "Sin respuesta.",
      };
      setMessages((prev) => [...prev, assistantMessage]);
    } catch (error) {
      console.error("Error en el chat:", error);
      setMessages((prev) => [
        ...prev,
        {
          role: "assistant",
          content: "Ocurri√≥ un error al procesar tu mensaje.",
        },
      ]);
    } finally {
      setIsLoading(false);
      setUserInput("");
    }
  };

  // Funci√≥n para alternar herramientas
  const toggleTool = (toolName: string) => {
    setTools((prev) =>
      prev.includes(toolName)
        ? prev.filter((t) => t !== toolName)
        : [...prev, toolName]
    );
  };

  return (
    <div className="flex flex-col h-screen border-4 border-black bg-white text-black font-sans">
      {/* Encabezado / Configuraci√≥n */}
      <div className="p-4 border-b-4 border-black bg-white -rotate-1 transform origin-top-left">
        <div className="flex justify-between items-center">
          <TitleComponent title="Chat RAG Data" variant="neobrutalism" />
          <ButtonLink href="/" variant="outline" size="lg">
            <p className="text-xl">Home</p>
          </ButtonLink>
        </div>

        <div className="flex flex-wrap gap-4 mt-4">
          {/* Modelo */}
          <div className="flex flex-col border-4 border-black p-2 bg-pink-300 rounded-lg">
            <label className="font-bold mb-1">Modelo:</label>
            <BrutalDropDown
              buttonLabel={model}
              options={[
                { label: "GPT-3.5", value: "gpt-3.5" },
                { label: "GPT-4", value: "gpt-4" },
                { label: "LLaMA2", value: "llama2" },
              ]}
              onSelect={(value) => setModel(value)}
              buttonBgClass="bg-pink-300"
              dropdownBgClass="bg-white"
            />
          </div>
          {/* Temperatura */}
          <div className="flex flex-col border-4 border-black p-2 bg-yellow-300 rounded-lg">
            <label className="font-bold mb-1">Temperatura:</label>
            <BrutalInput
              type="number"
              step="0.1"
              min="0"
              max="1"
              value={temperature.toString()}
              onChange={(e) => setTemperature(Number(e.target.value))}
              className="w-20 bg-white"
            />
          </div>
          {/* Retrieval */}
          <div className="flex flex-col border-4 border-black p-2 bg-green-300 rounded-lg">
            <label className="font-bold mb-1">Retrieval:</label>
            <BrutalDropDown
              buttonLabel={retrievalMethod}
              options={[
                { label: "Vector DB", value: "vector" },
                { label: "Graph DB", value: "graph" },
                { label: "H√≠brido", value: "hybrid" },
              ]}
              onSelect={(value) => setRetrievalMethod(value)}
              buttonBgClass="bg-green-300"
              dropdownBgClass="bg-white"
            />
          </div>
          {/* Herramientas */}
          <div className="flex flex-col border-4 border-black p-2 bg-blue-300 rounded-lg">
            <label className="font-bold mb-1">Herramientas:</label>
            <div className="space-y-1">
              <BrutalCheckbox
                label="Calculadora"
                checked={tools.includes("calculator")}
                onChange={() => toggleTool("calculator")}
              />
              <BrutalCheckbox
                label="Wikipedia"
                checked={tools.includes("wikipedia")}
                onChange={() => toggleTool("wikipedia")}
              />
            </div>
          </div>
          {/* Top K */}
          <div className="flex flex-col border-4 border-black p-2 bg-orange-300 rounded-lg">
            <label className="font-bold mb-1">Top K:</label>
            <BrutalInput
              type="number"
              min="1"
              value={topK.toString()}
              onChange={(e) => setTopK(Number(e.target.value))}
              className="w-16 bg-white"
            />
          </div>
          {/* Chunk Size */}
          <div className="flex flex-col border-4 border-black p-2 bg-purple-300 rounded-lg">
            <label className="font-bold mb-1">Chunk Size:</label>
            <BrutalInput
              type="number"
              min="128"
              value={chunkSize.toString()}
              onChange={(e) => setChunkSize(Number(e.target.value))}
              className="w-20 bg-white"
            />
          </div>
        </div>
      </div>

      {/* Secci√≥n de Mensajes */}
      <div className="flex-1 p-4 overflow-auto border-b-4 border-black bg-gray-100 relative">
        {messages.map((msg, idx) => (
          <div
            key={idx}
            className={`p-3 mb-4 max-w-2xl border-4 border-black rounded-lg ${
              msg.role === "system"
                ? "bg-gray-300 self-center mx-auto"
                : msg.role === "assistant"
                ? "bg-green-200 self-start"
                : "bg-blue-200 self-end"
            }`}
          >
            <b className="uppercase">{msg.role}:</b> {msg.content}
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>

      {/* Input de Usuario */}
      <div className="p-4 bg-white -rotate-1 transform origin-bottom-left border-4 border-black">
        <div className="flex space-x-3">
          <BrutalInput
            type="text"
            placeholder="Escribe tu pregunta..."
            className="flex-1 p-4 border-4 border-black rounded-lg text-xl bg-white placeholder-black"
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !isLoading) {
                handleSend();
              }
            }}
          />
          <BrutalButton
            onClick={handleSend}
            disabled={isLoading}
            variant="red"
            className="px-6 py-4 rounded-lg text-xl border-4 border-black transition-transform hover:rotate-1 disabled:bg-gray-300 disabled:cursor-not-allowed"
          >
            {isLoading ? "Enviando..." : "Enviar"}
          </BrutalButton>
        </div>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ fill-form/

            üìÑ page.tsx
            Path: app\fill-form/page.tsx
            --------------------------------------------------
"use client";

import { useState } from "react";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { BrutalInput } from "../components/InputComponent/InputComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";

export interface Metadata {
  author: string;
  text: string;
  work: string;
  tags: string;
  themes: string;
  // Puedes agregar m√°s campos si lo requieres
}

export default function MetadataForm() {
  // Estado para los metadatos (tags y themes se mantienen como string para luego convertirlos, si es necesario)
  const [metadata, setMetadata] = useState<Metadata>({
    author: "",
    text: "",
    work: "",
    tags: "",
    themes: "",
  });
  const [generating, setGenerating] = useState(false);

  // Manejo de cambios en los inputs
  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setMetadata((prev) => ({ ...prev, [name]: value }));
  };

  // Funci√≥n para llamar al backend y generar autom√°ticamente tags y themes basado en el texto
  const handleGenerateMetadata = async () => {
    if (!metadata.text) return;
    setGenerating(true);
    try {
      const response = await fetch("/api/generateMetadata", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: metadata.text }),
      });
      const data = await response.json();
      // Se asume que el endpoint retorna { tags: string, themes: string }
      setMetadata((prev) => ({
        ...prev,
        tags: data.tags || "",
        themes: data.themes || "",
      }));
    } catch (error) {
      console.error("Error generando metadata:", error);
    } finally {
      setGenerating(false);
    }
  };

  // Funci√≥n para enviar los metadatos al backend
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await fetch("/api/submitMetadata", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(metadata),
      });
      if (!response.ok) {
        throw new Error("Error al enviar los metadatos");
      }
      alert("Metadatos enviados correctamente");
      // Reiniciar formulario
      setMetadata({
        author: "",
        text: "",
        work: "",
        tags: "",
        themes: "",
      });
    } catch (error) {
      console.error("Error en el env√≠o:", error);
    }
  };

  return (
    <div className="container mx-auto p-4 min-h-screen flex flex-col items-center justify-center bg-yellow-100">
      <TitleComponent title="Send Your Data" variant="neobrutalism" />

      <form
        onSubmit={handleSubmit}
        className="max-w-xl mx-auto p-4 border-4 border-black bg-white rounded-lg space-y-6"
      >
        <h2 className="text-2xl font-bold mb-4">Formulario de Metadatos</h2>
        <BrutalInput
          type="text"
          name="author"
          value={metadata.author}
          onChange={handleChange}
          placeholder="Autor"
          className="w-full mb-4 text-xl"
        />
        <textarea
          name="text"
          value={metadata.text}
          onChange={handleChange}
          placeholder="Texto"
          className="w-full p-4 border-4 border-black rounded-lg text-xl bg-orange-300 placeholder-black mb-4"
        />
        <BrutalInput
          type="text"
          name="work"
          value={metadata.work}
          onChange={handleChange}
          placeholder="Obra"
          className="w-full mb-4 text-xl"
        />
        <BrutalInput
          type="text"
          name="tags"
          value={metadata.tags}
          onChange={handleChange}
          placeholder="Tags (separados por coma, espacios permitidos)"
          className="w-full mb-4 text-xl"
        />
        <BrutalInput
          type="text"
          name="themes"
          value={metadata.themes}
          onChange={handleChange}
          placeholder="Themes (separados por coma, espacios permitidos)"
          className="w-full mb-4 text-xl"
        />

        <div className="flex flex-col space-y-4">
          <BrutalButton
            type="button"
            onClick={handleGenerateMetadata}
            disabled={generating || !metadata.text}
            variant="teal"
          >
            {generating ? "Generando..." : "Generar Tags y Themes"}
          </BrutalButton>
          <BrutalButton type="submit" variant="blue">
            Enviar Metadatos
          </BrutalButton>
        </div>
      </form>
      <div className="mt-4 flex justify-center">
        <ButtonLink href="/" variant="outline" size="lg">
          <p className="text-xl">Home</p>
        </ButtonLink>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ just-images/

            üìÑ page.tsx
            Path: app\just-images/page.tsx
            --------------------------------------------------
"use client";

import { useState, useCallback } from "react";
import { useDropzone } from "react-dropzone";
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { BrutalInput } from "../components/InputComponent/InputComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";

interface Metadata {
  author: string;
  description: string;
  date: string;
  book: string;
  tags: string[];
  themes: string[];
  [key: string]: string | string[];
}

export default function JustImages() {
  const [step, setStep] = useState<1 | 2 | 3>(1);

  // Para la imagen y su ruta
  const [file, setFile] = useState<File | null>(null);
  const [filePath, setFilePath] = useState<string>("");

  // Estados de carga y generaci√≥n
  const [uploading, setUploading] = useState(false);
  const [generatingDescription, setGeneratingDescription] = useState(false);

  // Metadatos
  const [metadata, setMetadata] = useState<Metadata>({
    author: "",
    description: "",
    date: "",
    book: "",
    tags: [],
    themes: [],
  });
  const [customFields, setCustomFields] = useState<string[]>([]);

  // Para inputs de tags y themes
  const [tagsInput, setTagsInput] = useState<string>("");
  const [themesInput, setThemesInput] = useState<string>("");

  // Configuraci√≥n de Dropzone
  const onDrop = useCallback((acceptedFiles: File[]) => {
    setFile(acceptedFiles[0]);
  }, []);
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { "image/*": [] },
  });

  // Paso 1: Subir Imagen
  const handleUpload = async () => {
    if (!file) return;
    setUploading(true);
    try {
      const formData = new FormData();
      formData.append("file", file);
      const uploadResponse = await fetch("/api/upload", {
        method: "POST",
        body: formData,
      });
      const uploadData = await uploadResponse.json();
      console.log("Imagen subida:", uploadData);
      setFilePath(uploadData.file_path);
      setStep(2);
    } catch (error) {
      console.error("Error al subir la imagen:", error);
    } finally {
      setUploading(false);
    }
  };

  // Paso 2: Configurar Metadatos y Generar Descripci√≥n
  const handleMetadataChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setMetadata((prev) => ({ ...prev, [name]: value }));
  };

  const addCustomField = () => {
    const fieldName = prompt("Ingrese el nombre del nuevo campo:");
    if (fieldName && !customFields.includes(fieldName)) {
      setCustomFields((prev) => [...prev, fieldName]);
      setMetadata((prev) => ({ ...prev, [fieldName]: "" }));
    }
  };

  const handleGenerateDescription = async () => {
    if (!filePath) return;
    setGeneratingDescription(true);
    try {
      const response = await fetch("/api/generateDescription", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ image_path: filePath }),
      });
      const data = await response.json();
      console.log("Respuesta de generaci√≥n:", data);

      setMetadata((prev) => ({
        ...prev,
        description: data.description || "",
        tags: data.tags || [],
        themes: data.themes || [],
      }));

      setTagsInput(data.tags ? data.tags.join(", ") : "");
      setThemesInput(data.themes ? data.themes.join(", ") : "");
    } catch (error) {
      console.error("Error al generar la descripci√≥n:", error);
    } finally {
      setGeneratingDescription(false);
    }
  };

  // Env√≠o final
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const tagsArray = tagsInput
      .split(",")
      .map((item) => item.trim())
      .filter((item) => item);
    const themesArray = themesInput
      .split(",")
      .map((item) => item.trim())
      .filter((item) => item);
    const submissionData = {
      imageUrl: filePath,
      ...metadata,
      tags: tagsArray,
      themes: themesArray,
    };
    try {
      const backendResponse = await fetch("/api/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(submissionData),
      });
      if (!backendResponse.ok) {
        throw new Error("Error al enviar los datos al backend");
      }
      console.log("Datos enviados correctamente");
      setStep(3);
    } catch (error) {
      console.error("Error en el env√≠o final:", error);
    }
  };

  // Paso 3: Final
  const handleNewImage = () => {
    setFile(null);
    setFilePath("");
    setMetadata({
      author: "",
      description: "",
      date: "",
      book: "",
      tags: [],
      themes: [],
    });
    setTagsInput("");
    setThemesInput("");
    setCustomFields([]);
    setStep(1);
  };

  return (
    <div className="container mx-auto p-4 min-h-screen flex flex-col items-center justify-center bg-yellow-100">
      <TitleComponent title="Send Your Image" variant="neobrutalism" />
      <div className="max-w-xl mx-auto p-4 border-4 border-black bg-white rounded-lg space-y-6">
        {step === 1 && (
          <div>
            <h2 className="text-2xl font-bold mb-4">Paso 1: Subir Imagen</h2>
            <div
              {...getRootProps()}
              className={`p-6 border-4 border-black rounded-lg text-center cursor-pointer text-2xl ${
                isDragActive ? "bg-green-300" : "bg-blue-300"
              }`}
            >
              <input {...getInputProps()} />
              {file ? (
                <p>Imagen seleccionada: {file.name}</p>
              ) : (
                <p className="text-lg font-bold">
                  Arrastra y suelta una imagen, o haz click para seleccionar
                </p>
              )}
            </div>
            <BrutalButton
              onClick={handleUpload}
              disabled={!file || uploading}
              variant="blue"
              className="mt-4"
            >
              {uploading ? "Subiendo..." : "Subir Imagen"}
            </BrutalButton>
          </div>
        )}

        {step === 2 && (
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="flex justify-between items-center mb-4">
              <BrutalButton
                onClick={() => setStep(1)}
                variant="gray"
                className="text-black"
              >
                Volver
              </BrutalButton>
              <h2 className="text-2xl font-bold">Paso 2: Metadatos</h2>
            </div>
            <p className="mb-2">Imagen subida en: {filePath}</p>

            {/* Campos de metadatos */}
            <BrutalInput
              type="text"
              name="author"
              value={metadata.author}
              onChange={handleMetadataChange}
              placeholder="Autor"
              className="w-full text-xl mb-2"
            />
            <BrutalInput
              type="text"
              name="book"
              value={metadata.book}
              onChange={handleMetadataChange}
              placeholder="Libro"
              className="w-full text-xl mb-2"
            />
            <BrutalInput
              type="date"
              name="date"
              value={metadata.date}
              onChange={handleMetadataChange}
              className="w-full text-xl mb-2"
            />
            <textarea
              name="description"
              value={metadata.description}
              onChange={handleMetadataChange}
              placeholder="Descripci√≥n (editable)"
              className="w-full p-4 border-4 border-black rounded-lg text-xl bg-orange-300 placeholder-black"
            />
            <BrutalInput
              type="text"
              name="tags"
              value={tagsInput}
              onChange={(e) => setTagsInput(e.target.value)}
              placeholder="Tags (separados por coma, espacios permitidos)"
              className="w-full text-xl"
            />
            <BrutalInput
              type="text"
              name="themes"
              value={themesInput}
              onChange={(e) => setThemesInput(e.target.value)}
              placeholder="Themes (separados por coma, espacios permitidos)"
              className="w-full text-xl"
            />

            {/* Campos personalizados */}
            {customFields.map((field) => (
              <BrutalInput
                key={field}
                type="text"
                name={field}
                value={metadata[field] as string}
                onChange={handleMetadataChange}
                placeholder={field}
                className="w-full text-xl bg-green-300"
              />
            ))}
            <BrutalButton variant="red" onClick={addCustomField}>
              A√±adir campo personalizado
            </BrutalButton>

            {/* Bot√≥n para generar descripci√≥n */}
            <BrutalButton
              type="button"
              onClick={handleGenerateDescription}
              disabled={generatingDescription || !filePath}
              variant="teal"
            >
              {generatingDescription ? "Generando..." : "Generar Descripci√≥n"}
            </BrutalButton>

            {/* Bot√≥n para enviar los datos finales */}
            <BrutalButton
              type="submit"
              disabled={uploading || generatingDescription || !filePath}
              variant="blue"
            >
              Enviar
            </BrutalButton>
          </form>
        )}

        {step === 3 && (
          <div className="text-center space-y-4">
            <h2 className="text-2xl font-bold">¬°Proceso Finalizado!</h2>
            <p>Los datos han sido enviados correctamente.</p>
            <BrutalButton variant="green" onClick={handleNewImage}>
              Subir otra imagen
            </BrutalButton>
          </div>
        )}
      </div>
      <div className="mt-4 flex justify-center">
        <ButtonLink href="/" variant="outline" size="lg">
          <p className="text-xl">Home</p>
        </ButtonLink>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ lib/

            üìÑ utils.ts
            Path: app\lib/utils.ts
            --------------------------------------------------
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


            --------------------------------------------------

        üìÅ ocr/

            üìÑ page.tsx
            Path: app\ocr/page.tsx
            --------------------------------------------------
"use client";

import { useState, useCallback } from "react";
import { useDropzone } from "react-dropzone";
import {
  uploadImage,
  uploadJSON,
  updateVariables,
  runFlow,
  listFiles,
} from "../utils/langflowAPI";
import config from "../config.json";
import { CategoryButton } from "../components/LinkButton";
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { BrutalInput } from "../components/InputComponent/InputComponent";
import BrutalDropDown from "../components/DropDownComponent/DropdownComponent";
import BrutalCheckbox from "../components/CheckBoxComponent/CheckBoxComponent";

/** Estructura de los metadatos */
interface Metadata {
  author: string;
  text: string; // Aqu√≠ eventualmente ir√° el texto del OCR
  date: string;
  book: string;
  tags: string[];
  themes: string[];
  [key: string]: string | string[];
}

export default function ImageOcrMultiStep() {
  // Estados principales
  const [step, setStep] = useState<1 | 2 | 3 | 4>(1);

  // Para la etapa de subir imagen
  const [file, setFile] = useState<File | null>(null);
  const [filePath, setFilePath] = useState<string>(""); // Path devuelto por /api/upload
  const [uploading, setUploading] = useState(false);

  // Para la etapa de OCR
  const [ocrResult, setOcrResult] = useState<string>(""); // Texto devuelto por /api/ocr
  const [loadingOcr, setLoadingOcr] = useState(false);
  const [tagsInput, setTagsInput] = useState<string>("");
  const [themesInput, setThemesInput] = useState<string>("");

  // Metadatos
  const [metadata, setMetadata] = useState<Metadata>({
    author: config.default_author,
    text: "",
    date: "",
    book: config.default_work,
    tags: [],
    themes: [],
  });
  const [customFields, setCustomFields] = useState<string[]>([]);

  // Configuraci√≥n por defecto para OCR (podr√≠a venir de un JSON)
  const defaultOcrConfig = {
    language: "eng",
    ocr_mode: "Auto (PSM 3)",
    apply_otsu: false,
  };

  // Estado para configuraci√≥n avanzada de OCR
  const [useAdvancedOcr, setUseAdvancedOcr] = useState(false);
  const [advancedOcrConfig, setAdvancedOcrConfig] = useState(defaultOcrConfig);

  // ===============================
  // Dropzone para imagen
  // ===============================
  const onDrop = useCallback((acceptedFiles: File[]) => {
    setFile(acceptedFiles[0]);
  }, []);
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { "image/*": [] },
  });

  // ===============================
  // STEP 1: Subir Imagen
  // ===============================
  async function handleUpload() {
    if (!file) return;
    setUploading(true);
    try {
      const uploadResponse = await uploadImage(file);
      const uploadData = await uploadResponse;
      console.log("File uploaded:", uploadData);
      setFilePath(uploadData.file_path);
      await updateVariables({
        image_path: uploadData.file_path,
      });
      setStep(2);
      const files = await listFiles();
      console.log("Files:", files);
    } catch (err) {
      console.error("Upload error:", err);
    } finally {
      setUploading(false);
    }
  }

  // ===============================
  // STEP 2: Generar OCR
  // ===============================
  async function handleGenerateOcr() {
    if (!filePath) return;
    setLoadingOcr(true);
    try {
      const ocrParams = useAdvancedOcr ? advancedOcrConfig : defaultOcrConfig;
      const ocrResponse = await runFlow({ image_path: filePath, ...ocrParams });
      const ocrData = await ocrResponse;
      console.log("OCR data:", ocrData);
      const textFound =
        ocrData.outputs?.[0]?.outputs?.[0]?.artifacts?.message ||
        ocrData.message ||
        "No text found";
      setOcrResult(textFound);
      setMetadata((prev) => ({ ...prev, text: textFound }));
      setStep(3);
    } catch (err) {
      console.error("OCR error:", err);
    } finally {
      setLoadingOcr(false);
    }
  }

  // ===============================
  // STEP 3: Metadatos
  // ===============================
  const handleMetadataChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setMetadata((prev) => ({ ...prev, [name]: value }));
  };

  const handleArrayMetadataChange = (
    e: React.ChangeEvent<HTMLInputElement>,
    field: "tags" | "themes"
  ) => {
    const values = e.target.value.split(",").map((item) => item.trim());
    setMetadata((prev) => ({ ...prev, [field]: values }));
  };

  function addCustomField() {
    const fieldName = prompt("Enter the name of the new field:");
    if (fieldName && !customFields.includes(fieldName)) {
      setCustomFields((prev) => [...prev, fieldName]);
      setMetadata((prev) => ({ ...prev, [fieldName]: "" }));
    }
  }

  // ===============================
  // STEP 3: Guardar Metadatos
  // ===============================
  async function handleSaveMetadata() {
    const tagsArray = tagsInput
      .split(",")
      .map((item) => item.trim())
      .filter((item) => item);
    const themesArray = themesInput
      .split(",")
      .map((item) => item.trim())
      .filter((item) => item);
    const submissionData = {
      imageUrl: filePath,
      ...metadata,
      tags: tagsArray,
      themes: themesArray,
    };
    try {
      const backendResponse = await fetch("/api/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(submissionData),
      });
      if (!backendResponse.ok) {
        throw new Error("Failed to submit data to backend");
      }
      console.log("Metadata submitted successfully");
      setStep(4);
    } catch (err) {
      console.error("Error submitting metadata:", err);
    }
  }

  // ===============================
  // STEP 4: Final / Nueva imagen
  // ===============================
  function handleNewImage() {
    setFile(null);
    setFilePath("");
    setOcrResult("");
    setMetadata({
      author: "",
      text: "",
      date: "",
      book: "",
      tags: [],
      themes: [],
    });
    setCustomFields([]);
    setUseAdvancedOcr(false);
    setAdvancedOcrConfig(defaultOcrConfig);
    setStep(1);
  }

  function clearAdvancedDefaults() {
    setAdvancedOcrConfig({ language: "", ocr_mode: "", apply_otsu: false });
  }

  return (
    <div className="container mx-auto p-4 min-h-screen flex flex-col items-center justify-center bg-yellow-100">
      <TitleComponent title="Send Image and OCR it" variant="neobrutalism" />
      <div className="max-w-xl mx-auto p-4 border-4 border-black bg-white rounded-lg space-y-4">
        {step === 1 && (
          <div>
            <h2 className="text-2xl font-bold mb-4">Step 1: Upload Image</h2>
            <div
              {...getRootProps()}
              className={`p-6 border-4 border-black rounded-lg text-center cursor-pointer text-2xl ${
                isDragActive ? "bg-green-300 rotate-1" : "bg-blue-300 -rotate-1"
              }`}
            >
              <input {...getInputProps()} />
              {file ? (
                <p className="text-2xl text-black font-bold">
                  File selected: {file.name}
                </p>
              ) : (
                <p className="text-2xl text-black font-bold">
                  DRAG 'N' DROP AN IMAGE HERE, OR CLICK TO SELECT
                </p>
              )}
            </div>
            <BrutalButton
              onClick={handleUpload}
              disabled={!file || uploading}
              variant="blue"
            >
              {uploading ? "Uploading..." : "UPLOAD IMAGE"}
            </BrutalButton>
          </div>
        )}

        {step === 2 && (
          <div>
            <div className="flex justify-between mb-4">
              <BrutalButton onClick={() => setStep(1)} variant="green">
                Go Back
              </BrutalButton>
              <h2 className="text-2xl font-bold">Step 2: Generate OCR</h2>
            </div>
            <p className="text-lg font-bold">
              Image uploaded in filepath: {filePath}
            </p>
            <BrutalButton
              onClick={() => setUseAdvancedOcr((prev) => !prev)}
              variant="teal"
            >
              {useAdvancedOcr
                ? "Ocultar configuraci√≥n avanzada"
                : "Mostrar configuraci√≥n avanzada"}
            </BrutalButton>
            {useAdvancedOcr && (
              <div className="mt-4 p-4 border-2 border-indigo-400 rounded-lg">
                <h3 className="text-xl font-bold mb-2">
                  Configuraci√≥n Avanzada de OCR
                </h3>
                <div className="mb-2">
                  <label className="block mb-1">Idioma OCR</label>
                  <BrutalInput
                    type="text"
                    value={advancedOcrConfig.language}
                    onChange={(e) =>
                      setAdvancedOcrConfig((prev) => ({
                        ...prev,
                        language: e.target.value,
                      }))
                    }
                    placeholder="eng o spa, etc."
                    focusBgClass="focus:bg-[#FFA6F6]"
                  />
                </div>
                <div className="mb-2">
                  <label className="block mb-1">Modo OCR (PSM)</label>
                  <BrutalDropDown
                    buttonLabel={advancedOcrConfig.ocr_mode}
                    options={[
                      { label: "Auto (PSM 3)", value: "Auto (PSM 3)" },
                      {
                        label: "Un bloque (PSM 6)",
                        value: "Un bloque (PSM 6)",
                      },
                      {
                        label: "Manuscrito/Desordenado (PSM 13)",
                        value: "Manuscrito/Desordenado (PSM 13)",
                      },
                    ]}
                    onSelect={(value) =>
                      setAdvancedOcrConfig((prev) => ({
                        ...prev,
                        ocr_mode: value,
                      }))
                    }
                    buttonBgClass="bg-green-300"
                    dropdownBgClass="bg-[#FFA6F6]"
                  />
                </div>
                <div className="mb-2 flex items-center">
                  <BrutalCheckbox
                    label="Usar umbral Otsu"
                    onChange={(e) =>
                      setAdvancedOcrConfig((prev) => ({
                        ...prev,
                        apply_otsu: e.target.checked,
                      }))
                    }
                  />
                </div>
                <BrutalButton onClick={clearAdvancedDefaults} variant="red">
                  Limpiar defaults
                </BrutalButton>
              </div>
            )}
            <BrutalButton
              onClick={handleGenerateOcr}
              disabled={loadingOcr}
              variant="orange"
            >
              {loadingOcr ? "Generating OCR..." : "Generar OCR"}
            </BrutalButton>
          </div>
        )}

        {step === 3 && (
          <div>
            <div className="flex justify-between mb-4">
              <BrutalButton onClick={() => setStep(2)} variant="gray">
                Volver
              </BrutalButton>
              <h2 className="text-2xl font-bold">Paso 3: Metadatos</h2>
            </div>
            <p className="mb-2">Texto OCR Detectado: {ocrResult}</p>
            <textarea
              name="text"
              value={metadata.text}
              onChange={handleMetadataChange}
              placeholder="Text from OCR"
              className="w-full p-4 border-4 border-black rounded-lg text-xl bg-orange-300 placeholder-black mb-4"
            />
            <BrutalInput
              type="text"
              name="author"
              value={metadata.author}
              onChange={handleMetadataChange}
              placeholder="Author"
              className="mb-4"
            />
            <BrutalInput
              type="text"
              name="book"
              value={metadata.book}
              onChange={handleMetadataChange}
              placeholder="Book"
              className="mb-4"
            />
            <BrutalInput
              type="date"
              name="date"
              value={metadata.date}
              onChange={handleMetadataChange}
              className="mb-4"
            />
            <BrutalInput
              type="text"
              name="tags"
              value={tagsInput}
              onChange={(e) => setTagsInput(e.target.value)}
              placeholder="Tags (separados por coma, se permiten espacios)"
              className="mb-4"
            />
            <BrutalInput
              type="text"
              name="themes"
              value={themesInput}
              onChange={(e) => setThemesInput(e.target.value)}
              placeholder="Themes (separados por coma, se permiten espacios)"
              className="mb-4"
            />
            {customFields.map((field) => (
              <BrutalInput
                key={field}
                type="text"
                name={field}
                value={metadata[field] as string}
                onChange={handleMetadataChange}
                placeholder={field}
                className="mb-4"
              />
            ))}
            <BrutalButton onClick={addCustomField} variant="red">
              ADD CUSTOM FIELD
            </BrutalButton>
            <BrutalButton
              onClick={handleSaveMetadata}
              variant="blue"
              className="ml-4"
            >
              Guardar Metadatos
            </BrutalButton>
          </div>
        )}

        {step === 4 && (
          <div className="text-center">
            <h2 className="text-2xl font-bold mb-4">¬°Proceso Finalizado!</h2>
            <p>¬øQuieres subir otra imagen?</p>
            <BrutalButton onClick={handleNewImage} variant="green">
              Subir otra
            </BrutalButton>
          </div>
        )}
      </div>
      <div className="mt-4 flex justify-center">
        <ButtonLink href="/" variant="outline" size="lg">
          <p className="text-xl">Home</p>
        </ButtonLink>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ pending/

            üìÑ page.tsx
            Path: app\pending/page.tsx
            --------------------------------------------------
"use client";
import { useEffect, useState } from "react";
import categorizerAPI, { FileMetadata } from "../utils/categorizerAPI";
import CustomCheckbox from "../components/CheckBoxComponent/CheckBoxComponent";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";

// Componente para visualizar y gestionar archivos pendientes
export default function PendingFilesList() {
  const [pendingFiles, setPendingFiles] = useState<FileMetadata[]>([]);
  const [selectedIds, setSelectedIds] = useState<string[]>([]);
  const [loading, setLoading] = useState<boolean>(false);

  // Solicitar archivos pendientes al montar el componente
  useEffect(() => {
    const fetchPendingFiles = async () => {
      setLoading(true);
      try {
        // Suponemos que pending significa processed = false
        const files = await categorizerAPI.getFiles({ processed: false });
        console.log(files);
        setPendingFiles(files);
      } catch (error) {
        console.error("Error fetching pending files:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchPendingFiles();
  }, []);

  // Manejar la selecci√≥n de un archivo
  const toggleSelection = (id: string) => {
    setSelectedIds((prev) =>
      prev.includes(id) ? prev.filter((sid) => sid !== id) : [...prev, id]
    );
  };

  // Acci√≥n sobre los archivos seleccionados
  const handleProcessSelected = () => {
    // Aqu√≠ podr√≠as redirigir al usuario, llamar a otra API, etc.
    console.log("Archivos seleccionados para procesar:", selectedIds);
    // Ejemplo: redirigir o actualizar el estado global de Zustand
  };

  return (
    <div className="p-4">
      <h2 className="text-2xl font-bold mb-4">Archivos Pendientes</h2>
      {loading ? (
        <p>Cargando archivos pendientes...</p>
      ) : pendingFiles.length === 0 ? (
        <p>No hay archivos pendientes.</p>
      ) : (
        <ul className="space-y-2">
          {pendingFiles.map((file) => (
            <li
              key={file.id}
              className="flex items-center justify-between p-2 border rounded"
            >
              <div className="flex items-center">
                <CustomCheckbox
                  checked={selectedIds.includes(file.id)}
                  onChange={() => toggleSelection(file.id)}
                  label={file.original_name}
                />
              </div>
              <span className="text-sm text-gray-500">{file.fileType}</span>
            </li>
          ))}
        </ul>
      )}
      <div className="mt-4">
        <BrutalButton
          onClick={handleProcessSelected}
          disabled={selectedIds.length === 0}
        >
          Procesar Seleccionados
        </BrutalButton>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ processing/

            üìÑ page.tsx
            Path: app\processing/page.tsx
            --------------------------------------------------
"use client";

import { useState, useEffect } from "react";
import { useFileStore } from "../store/filestore";
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";
import CustomCheckbox from "../components/CheckBoxComponent/CheckBoxComponent";
import categorizerAPI from "../utils/categorizerAPI";

// Tipo para los metadatos
type FileMetadata = {
  id: string;
  author?: string;
  title?: string;
  description?: string;
  tags: string[];
  sourceType?: string;
  extractedText?: string;
  processingStatus: "pending" | "processing" | "completed" | "failed";
  processingMethod?: "manual" | "llm" | "ocr";
};

export default function ProcessFiles() {
  const { getSelectedFiles } = useFileStore();
  const [files, setFiles] = useState(getSelectedFiles());
  const [fileMetadata, setFileMetadata] = useState<
    Record<string, FileMetadata>
  >({});
  const [currentFileId, setCurrentFileId] = useState<string | null>(null);
  const [autoFields, setAutoFields] = useState({
    author: false,
    title: false,
    description: false,
    tags: false,
  });
  const [isProcessing, setIsProcessing] = useState(false);

  // Inicializar metadatos
  useEffect(() => {
    const initialMetadata: Record<string, FileMetadata> = {};
    files.forEach((file) => {
      initialMetadata[file.id] = {
        id: file.id,
        tags: [],
        processingStatus: "pending",
      };
    });
    setFileMetadata(initialMetadata);

    // Seleccionar el primer archivo autom√°ticamente
    if (files.length > 0 && !currentFileId) {
      setCurrentFileId(files[0].id);
    }
  }, [files, currentFileId]);

  // Obtener el archivo actual
  const getCurrentFile = () => {
    return currentFileId ? files.find((f) => f.id === currentFileId) : null;
  };

  const getCurrentFileMetadata = () => {
    return currentFileId ? fileMetadata[currentFileId] : null;
  };

  // Determinar el tipo principal del archivo
  const getMainFileType = (file: any) => {
    return file?.type?.split("/")[0] || "unknown";
  };

  // Obtener opciones de procesamiento seg√∫n el tipo de archivo
  const getProcessingOptions = (file: any) => {
    const mainType = getMainFileType(file);

    switch (mainType) {
      case "image":
        return ["ocr", "llm", "manual"];
      case "video":
        return ["llm", "manual"];
      case "audio":
        return ["llm", "manual"];
      case "application":
        if (file.type.includes("json") || file.type.includes("pdf")) {
          return ["llm", "manual"];
        }
        return ["manual"];
      default:
        return ["manual"];
    }
  };

  // Actualizar metadata del archivo actual
  const updateCurrentFileMetadata = (updates: Partial<FileMetadata>) => {
    if (!currentFileId) return;

    setFileMetadata((prev) => ({
      ...prev,
      [currentFileId]: {
        ...prev[currentFileId],
        ...updates,
      },
    }));
  };

  // Procesar archivo con LLM
  const processWithLLM = async () => {
    const currentFile = getCurrentFile();
    if (!currentFile || !currentFile.filePath) return;

    setIsProcessing(true);
    updateCurrentFileMetadata({
      processingStatus: "processing",
      processingMethod: "llm",
    });

    try {
      // Llamar al API para procesar con LLM
      const result = await categorizerAPI.processFileWithLLM(
        currentFile.filePath,
        {
          extractAuthor: autoFields.author,
          extractTitle: autoFields.title,
          extractDescription: autoFields.description,
          extractTags: autoFields.tags,
        }
      );

      // Actualizar metadata con resultado
      updateCurrentFileMetadata({
        author: result.author,
        title: result.title,
        description: result.description,
        tags: result.tags || [],
        extractedText: result.extractedText,
        processingStatus: "completed",
      });
    } catch (error) {
      console.error("Error al procesar con LLM:", error);
      updateCurrentFileMetadata({ processingStatus: "failed" });
      alert(
        "Error al procesar archivo con LLM. Por favor, intenta nuevamente."
      );
    } finally {
      setIsProcessing(false);
    }
  };

  // Procesar imagen con OCR
  const processWithOCR = async () => {
    const currentFile = getCurrentFile();
    if (!currentFile || !currentFile.filePath) return;

    setIsProcessing(true);
    updateCurrentFileMetadata({
      processingStatus: "processing",
      processingMethod: "ocr",
    });

    try {
      // Llamar al API para OCR
      const result = await categorizerAPI.processImageWithOCR(
        currentFile.filePath
      );

      // Actualizar metadata con resultado
      updateCurrentFileMetadata({
        extractedText: result.text,
        processingStatus: "completed",
      });
    } catch (error) {
      console.error("Error al procesar con OCR:", error);
      updateCurrentFileMetadata({ processingStatus: "failed" });
      alert("Error al procesar imagen con OCR. Por favor, intenta nuevamente.");
    } finally {
      setIsProcessing(false);
    }
  };

  // Guardar metadatos finales
  const saveAllMetadata = async () => {
    setIsProcessing(true);
    try {
      const allMetadata = Object.values(fileMetadata);
      await categorizerAPI.saveFilesMetadata(allMetadata);
      alert("Metadatos guardados correctamente!");
    } catch (error) {
      console.error("Error al guardar metadatos:", error);
      alert("Error al guardar metadatos. Por favor, intenta nuevamente.");
    } finally {
      setIsProcessing(false);
    }
  };

  // Renderizar preview del archivo
  const renderFilePreview = () => {
    const currentFile = getCurrentFile();
    if (!currentFile) return null;

    const mainType = getMainFileType(currentFile);
    const fileURL = currentFile.filePath
      ? `${process.env.NEXT_PUBLIC_API_URL}/files/${currentFile.filePath}`
      : URL.createObjectURL(currentFile.file);

    switch (mainType) {
      case "image":
        return (
          <div className="border-4 border-black rounded-lg p-2 bg-gray-100">
            <img
              src={fileURL}
              alt={currentFile.file.name}
              className="max-h-64 max-w-full mx-auto object-contain"
            />
          </div>
        );
      case "video":
        return (
          <div className="border-4 border-black rounded-lg p-2 bg-gray-100">
            <video controls className="max-h-64 max-w-full mx-auto">
              <source src={fileURL} type={currentFile.type} />
              Tu navegador no soporta este video.
            </video>
          </div>
        );
      case "audio":
        return (
          <div className="border-4 border-black rounded-lg p-2 bg-gray-100">
            <audio controls className="w-full">
              <source src={fileURL} type={currentFile.type} />
              Tu navegador no soporta este audio.
            </audio>
          </div>
        );
      case "application":
        if (currentFile.type.includes("json")) {
          return (
            <div className="border-4 border-black rounded-lg p-2 bg-gray-100 overflow-auto max-h-64">
              <pre className="text-xs">
                {JSON.stringify(
                  JSON.parse(URL.createObjectURL(currentFile.file)),
                  null,
                  2
                )}
              </pre>
            </div>
          );
        }
        return (
          <div className="border-4 border-black rounded-lg p-2 bg-gray-100 flex items-center justify-center">
            <p className="text-center">
              <span className="text-3xl">üìÑ</span>
              <br />
              {currentFile.file.name}
            </p>
          </div>
        );
      default:
        return (
          <div className="border-4 border-black rounded-lg p-2 bg-gray-100 flex items-center justify-center">
            <p className="text-center">
              <span className="text-3xl">üóÉÔ∏è</span>
              <br />
              {currentFile.file.name}
            </p>
          </div>
        );
    }
  };

  // Agregar un tag
  const addTag = (tag: string) => {
    if (!currentFileId || !tag.trim()) return;

    setFileMetadata((prev) => {
      const currentTags = prev[currentFileId].tags || [];
      if (!currentTags.includes(tag)) {
        return {
          ...prev,
          [currentFileId]: {
            ...prev[currentFileId],
            tags: [...currentTags, tag.trim()],
          },
        };
      }
      return prev;
    });
  };

  // Eliminar un tag
  const removeTag = (tag: string) => {
    if (!currentFileId) return;

    setFileMetadata((prev) => {
      const currentTags = prev[currentFileId].tags || [];
      return {
        ...prev,
        [currentFileId]: {
          ...prev[currentFileId],
          tags: currentTags.filter((t) => t !== tag),
        },
      };
    });
  };

  // Renderizar secci√≥n de metadatos
  const renderMetadataForm = () => {
    const currentMetadata = getCurrentFileMetadata();
    if (!currentMetadata) return null;

    return (
      <div className="space-y-4 border-4 border-black rounded-lg p-4 bg-white">
        <h3 className="text-xl font-bold">Metadatos del Archivo</h3>

        <div className="grid grid-cols-1 gap-4">
          <div>
            <div className="flex justify-between items-center">
              <label className="font-bold">Autor</label>
              <CustomCheckbox
                checked={autoFields.author}
                onChange={() =>
                  setAutoFields((prev) => ({ ...prev, author: !prev.author }))
                }
                label="Auto"
              />
            </div>
            <input
              type="text"
              value={currentMetadata.author || ""}
              onChange={(e) =>
                updateCurrentFileMetadata({ author: e.target.value })
              }
              className="w-full p-2 border-4 border-black rounded-lg"
              placeholder="Autor del contenido"
            />
          </div>

          <div>
            <div className="flex justify-between items-center">
              <label className="font-bold">T√≠tulo</label>
              <CustomCheckbox
                checked={autoFields.title}
                onChange={() =>
                  setAutoFields((prev) => ({ ...prev, title: !prev.title }))
                }
                label="Auto"
              />
            </div>
            <input
              type="text"
              value={currentMetadata.title || ""}
              onChange={(e) =>
                updateCurrentFileMetadata({ title: e.target.value })
              }
              className="w-full p-2 border-4 border-black rounded-lg"
              placeholder="T√≠tulo del contenido"
            />
          </div>

          <div>
            <div className="flex justify-between items-center">
              <label className="font-bold">Descripci√≥n</label>
              <CustomCheckbox
                checked={autoFields.description}
                onChange={() =>
                  setAutoFields((prev) => ({
                    ...prev,
                    description: !prev.description,
                  }))
                }
                label="Auto"
              />
            </div>
            <textarea
              value={currentMetadata.description || ""}
              onChange={(e) =>
                updateCurrentFileMetadata({ description: e.target.value })
              }
              className="w-full p-2 border-4 border-black rounded-lg"
              rows={3}
              placeholder="Descripci√≥n del contenido"
            />
          </div>

          <div>
            <div className="flex justify-between items-center">
              <label className="font-bold">Tags</label>
              <CustomCheckbox
                checked={autoFields.tags}
                onChange={() =>
                  setAutoFields((prev) => ({ ...prev, tags: !prev.tags }))
                }
                label="Auto"
              />
            </div>
            <div className="flex space-x-2">
              <input
                type="text"
                id="tagInput"
                className="flex-1 p-2 border-4 border-black rounded-lg"
                placeholder="Agregar tag"
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    addTag((e.target as HTMLInputElement).value);
                    (e.target as HTMLInputElement).value = "";
                  }
                }}
              />
              <BrutalButton
                onClick={() => {
                  const input = document.getElementById(
                    "tagInput"
                  ) as HTMLInputElement;
                  addTag(input.value);
                  input.value = "";
                }}
                variant="teal"
              >
                +
              </BrutalButton>
            </div>
            <div className="flex flex-wrap gap-2 mt-2">
              {currentMetadata.tags.map((tag) => (
                <span
                  key={tag}
                  className="bg-blue-200 border-2 border-black px-2 py-1 rounded-lg flex items-center"
                >
                  {tag}
                  <button
                    onClick={() => removeTag(tag)}
                    className="ml-2 text-red-600 font-bold"
                  >
                    √ó
                  </button>
                </span>
              ))}
            </div>
          </div>

          {currentMetadata.extractedText && (
            <div>
              <label className="font-bold">Texto Extra√≠do</label>
              <div className="mt-1 p-2 border-4 border-black rounded-lg bg-gray-100 max-h-40 overflow-y-auto">
                <p className="whitespace-pre-wrap text-sm">
                  {currentMetadata.extractedText}
                </p>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="container mx-auto p-4 min-h-screen flex flex-col bg-yellow-100">
      <TitleComponent title="Procesar Archivos" variant="neobrutalism" />

      <div className="max-w-6xl mx-auto w-full">
        <div className="p-4 border-4 border-black bg-white rounded-lg">
          <div className="mb-4">
            <h2 className="text-2xl font-bold">
              Procesando {files.length} archivos
            </h2>
            <p>
              Extrae metadatos de tus archivos autom√°ticamente o de forma manual
            </p>
          </div>

          {/* Selector de archivos */}
          <div className="mb-6">
            <h3 className="text-xl font-bold mb-2">
              Selecciona un archivo para procesar:
            </h3>
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 max-h-40 overflow-y-auto p-2 border-2 border-black rounded-lg">
              {files.map((file) => (
                <div
                  key={file.id}
                  onClick={() => setCurrentFileId(file.id)}
                  className={`p-2 border-2 rounded-lg cursor-pointer text-sm truncate ${
                    currentFileId === file.id
                      ? "border-blue-500 bg-blue-100"
                      : "border-gray-300 hover:bg-gray-100"
                  } ${
                    fileMetadata[file.id]?.processingStatus === "completed"
                      ? "bg-green-100"
                      : fileMetadata[file.id]?.processingStatus === "processing"
                      ? "bg-yellow-100"
                      : fileMetadata[file.id]?.processingStatus === "failed"
                      ? "bg-red-100"
                      : ""
                  }`}
                >
                  <div className="flex items-center">
                    <span>
                      {getMainFileType(file) === "image" && "üñºÔ∏è"}
                      {getMainFileType(file) === "video" && "üé¨"}
                      {getMainFileType(file) === "audio" && "üéµ"}
                      {getMainFileType(file) === "application" && "üìÑ"}
                      {getMainFileType(file) === "unknown" && "üìÅ"}
                    </span>
                    <span className="ml-1 truncate">{file.file.name}</span>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {currentFileId && (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Columna izquierda: Preview y opciones de procesamiento */}
              <div className="space-y-4">
                <h3 className="text-xl font-bold">Vista previa</h3>
                {renderFilePreview()}

                <div className="border-4 border-black rounded-lg p-4 bg-white">
                  <h3 className="text-xl font-bold mb-2">
                    Opciones de procesamiento
                  </h3>

                  {/* Mostrar opciones seg√∫n el tipo de archivo */}
                  <div className="space-y-3">
                    {getProcessingOptions(getCurrentFile()).includes("ocr") && (
                      <BrutalButton
                        onClick={processWithOCR}
                        disabled={isProcessing}
                        variant="blue"
                        className="w-full"
                      >
                        {isProcessing
                          ? "Procesando..."
                          : "Extraer texto con OCR (Tesseract)"}
                      </BrutalButton>
                    )}

                    {getProcessingOptions(getCurrentFile()).includes("llm") && (
                      <BrutalButton
                        onClick={processWithLLM}
                        disabled={isProcessing}
                        variant="purple"
                        className="w-full"
                      >
                        {isProcessing ? "Procesando..." : "Analizar con LLM"}
                      </BrutalButton>
                    )}

                    <div className="mt-4 p-3 border-2 border-black rounded-lg bg-yellow-100">
                      <h4 className="font-bold">
                        Campos a extraer autom√°ticamente:
                      </h4>
                      <div className="grid grid-cols-2 gap-2 mt-2">
                        <CustomCheckbox
                          checked={autoFields.author}
                          onChange={() =>
                            setAutoFields((prev) => ({
                              ...prev,
                              author: !prev.author,
                            }))
                          }
                          label="Autor"
                        />
                        <CustomCheckbox
                          checked={autoFields.title}
                          onChange={() =>
                            setAutoFields((prev) => ({
                              ...prev,
                              title: !prev.title,
                            }))
                          }
                          label="T√≠tulo"
                        />
                        <CustomCheckbox
                          checked={autoFields.description}
                          onChange={() =>
                            setAutoFields((prev) => ({
                              ...prev,
                              description: !prev.description,
                            }))
                          }
                          label="Descripci√≥n"
                        />
                        <CustomCheckbox
                          checked={autoFields.tags}
                          onChange={() =>
                            setAutoFields((prev) => ({
                              ...prev,
                              tags: !prev.tags,
                            }))
                          }
                          label="Tags"
                        />
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Columna derecha: Formulario de metadatos */}
              <div>{renderMetadataForm()}</div>
            </div>
          )}

          {/* Botones de acci√≥n */}
          <div className="mt-6 flex justify-between">
            <ButtonLink href="/upload" variant="outline" size="lg">
              <p className="text-xl">Volver</p>
            </ButtonLink>

            <BrutalButton
              onClick={saveAllMetadata}
              disabled={isProcessing || files.length === 0}
              variant="green"
            >
              {isProcessing ? "Guardando..." : "Guardar metadatos"}
            </BrutalButton>
          </div>
        </div>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ store/

            üìÑ filestore.ts
            Path: app\store/filestore.ts
            --------------------------------------------------
// src/store/fileStore.ts
import { create } from "zustand";
import { persist } from "zustand/middleware";
interface FileItem {
  filePath: any;
  file: File;
  id: string;
  file_url?: string;
  selected: boolean;
  type: string;
  original_name?: string;
}

interface FileStore {
  files: FileItem[];
  addFiles: (newFiles: FileItem[]) => void;
  updateFilePath: (id: string, path: string) => void;
  clearFiles: () => void;
  toggleSelection: (id: string) => void;
  toggleAllSelection: (selected: boolean) => void;
  getSelectedFiles: () => FileItem[];
  filterByType: (type: string) => FileItem[];
}

// Store de Zustand con persistencia
export const useFileStore = create<FileStore>()(
  persist(
    (set, get) => ({
      files: [],
      addFiles: (newFiles) =>
        set((state) => ({
          files: [...state.files, ...newFiles],
        })),
      updateFilePath: (id, path) =>
        set((state) => ({
          files: state.files.map((file) =>
            file.id === id ? { ...file, filePath: path } : file
          ),
        })),
      clearFiles: () => set({ files: [] }),
      toggleSelection: (id) =>
        set((state) => ({
          files: state.files.map((file) =>
            file.id === id ? { ...file, selected: !file.selected } : file
          ),
        })),
      toggleAllSelection: (selected) =>
        set((state) => ({
          files: state.files.map((file) => ({ ...file, selected })),
        })),
      getSelectedFiles: () => get().files.filter((file) => file.selected),
      filterByType: (type) =>
        get().files.filter((file) =>
          type === "all" ? true : file.type.startsWith(type)
        ),
    }),
    {
      name: "file-storage",
      partialize: (state) => ({ files: state.files.filter((f) => f.file_url) }),
    }
  )
);


            --------------------------------------------------

        üìÅ upload-files/

            üìÑ page.tsx
            Path: app\upload-files/page.tsx
            --------------------------------------------------
"use client";

import { useState, useCallback } from "react";
import { useDropzone } from "react-dropzone";
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";
import categorizerAPI from "../utils/categorizerAPI";
import CustomCheckbox from "../components/CheckBoxComponent/CheckBoxComponent";
import { useFileStore } from "../store/filestore";

// Componente principal
export default function MultipleFileUpload() {
  const [step, setStep] = useState<1 | 2 | 3>(1);
  const [uploading, setUploading] = useState(false);
  const [filterType, setFilterType] = useState<string>("all");

  // Acceso al store
  const {
    files,
    addFiles,
    updateFilePath,
    clearFiles,
    toggleSelection,
    toggleAllSelection,
    getSelectedFiles,
    filterByType,
  } = useFileStore();

  // Configuraci√≥n de Dropzone
  const onDrop = useCallback(
    (acceptedFiles: File[]) => {
      const newFiles = acceptedFiles.map((file) => ({
        file,
        id: `${file.name}-${Date.now()}-${Math.random()
          .toString(36)
          .substring(2, 9)}`,
        selected: false,
        type: file.type,
      }));
      addFiles(newFiles);
    },
    [addFiles]
  );

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    multiple: true,
  });

  // Paso 1: Subir archivos
  const handleUpload = async () => {
    if (files.length === 0) return;

    setUploading(true);
    try {
      // Filtrar archivos no subidos
      const filesToUpload = files.filter((fileItem) => !fileItem.filePath);
      const fileObjects = filesToUpload.map((fileItem) => fileItem.file);

      // Llamar a la API para subir archivos
      const uploadedFiles = await categorizerAPI.uploadFiles(fileObjects);

      // Actualizar rutas en el store
      uploadedFiles.forEach((fileMetadata) => {
        const matchingFile = filesToUpload.find(
          (f) => f.file.name === fileMetadata.fileName
        );
        if (matchingFile) {
          updateFilePath(matchingFile.id, fileMetadata.filePath);
        }
      });

      setStep(2);
    } catch (error) {
      console.error("Error al subir los archivos:", error);
      alert("Error al subir archivos. Por favor intenta nuevamente.");
    } finally {
      setUploading(false);
    }
  };
  // Obtener lista de archivos filtrados
  const getFilteredFiles = () => {
    return filterByType(filterType);
  };

  // Obtener tipos √∫nicos de archivos
  const getUniqueFileTypes = () => {
    const types = new Set<string>();
    files.forEach((file) => {
      const mainType = file.type.split("/")[0];
      types.add(mainType);
    });
    return Array.from(types);
  };

  // Manejar la selecci√≥n de archivos para procesar
  const handleProcessFiles = () => {
    const selectedFiles = getSelectedFiles();
    if (selectedFiles.length === 0) {
      alert("Por favor, selecciona al menos un archivo para procesar");
      return;
    }

    setStep(3);
  };

  // Iniciar nuevo proceso
  const handleNewUpload = () => {
    clearFiles();
    setStep(1);
  };

  return (
    <div className="container mx-auto p-4 min-h-screen flex flex-col items-center justify-center bg-yellow-100">
      <TitleComponent title="Upload Multiple Files" variant="neobrutalism" />
      <div className="max-w-3xl mx-auto p-4 border-4 border-black bg-white rounded-lg space-y-6">
        {step === 1 && (
          <div>
            <h2 className="text-2xl font-bold mb-4">
              Paso 1: Seleccionar Archivos
            </h2>
            <div
              {...getRootProps()}
              className={`p-6 border-4 border-black rounded-lg text-center cursor-pointer text-2xl ${
                isDragActive ? "bg-green-300" : "bg-blue-300"
              }`}
            >
              <input {...getInputProps()} />
              {files.length > 0 ? (
                <p>{files.length} archivos seleccionados</p>
              ) : (
                <p className="text-lg font-bold">
                  Arrastra y suelta archivos, o haz click para seleccionar
                </p>
              )}
            </div>

            {files.length > 0 && (
              <div className="mt-4 border-2 border-black p-3 rounded-lg max-h-60 overflow-y-auto">
                <h3 className="text-lg font-bold mb-2">
                  Archivos seleccionados:
                </h3>
                <ul className="space-y-2">
                  {files.map((fileItem) => (
                    <li
                      key={fileItem.id}
                      className="flex items-center justify-between p-2 border-b border-gray-300"
                    >
                      <div className="flex items-center">
                        <span className="text-sm font-medium truncate max-w-xs">
                          {fileItem.file.name} (
                          {(fileItem.file.size / 1024).toFixed(2)} KB)
                        </span>
                      </div>
                      <span className="text-xs bg-gray-200 px-2 py-1 rounded">
                        {fileItem.type}
                      </span>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            <div className="mt-4 flex justify-between">
              <BrutalButton
                onClick={() => clearFiles()}
                disabled={files.length === 0}
                variant="red"
              >
                Limpiar Todo
              </BrutalButton>
              <BrutalButton
                onClick={handleUpload}
                disabled={files.length === 0 || uploading}
                variant="blue"
              >
                {uploading ? "Subiendo..." : "Subir Archivos"}
              </BrutalButton>
            </div>
          </div>
        )}

        {step === 2 && (
          <div>
            <div className="flex justify-between items-center mb-4">
              <BrutalButton
                onClick={() => setStep(1)}
                variant="gray"
                className="text-black"
              >
                Volver
              </BrutalButton>
              <h2 className="text-2xl font-bold">
                Paso 2: Seleccionar Archivos para Procesar
              </h2>
            </div>

            <div className="mb-4 flex items-center space-x-2">
              <span className="font-medium">Filtrar por tipo:</span>
              <select
                className="p-2 border-3 border-black rounded-lg bg-purple-200"
                value={filterType}
                onChange={(e) => setFilterType(e.target.value)}
              >
                <option value="all">Todos los tipos</option>
                {getUniqueFileTypes().map((type) => (
                  <option key={type} value={type}>
                    {type}
                  </option>
                ))}
              </select>

              <BrutalButton
                onClick={() => toggleAllSelection(true)}
                variant="teal"
                className="ml-auto"
              >
                Seleccionar Todos
              </BrutalButton>
              <BrutalButton
                onClick={() => toggleAllSelection(false)}
                variant="green"
              >
                Deseleccionar Todos
              </BrutalButton>
            </div>

            <div className="border-2 border-black p-3 rounded-lg max-h-96 overflow-y-auto">
              <h3 className="text-lg font-bold mb-2">Archivos disponibles:</h3>
              {getFilteredFiles().length > 0 ? (
                <ul className="space-y-2">
                  {getFilteredFiles().map((fileItem) => (
                    <li
                      key={fileItem.id}
                      className={`flex items-center justify-between p-2 border-b border-gray-300 rounded ${
                        fileItem.selected ? "bg-green-100" : ""
                      }`}
                    >
                      <div className="flex items-center">
                        <CustomCheckbox
                          onChange={() => toggleSelection(fileItem.id)}
                          checked={fileItem.selected}
                          label={fileItem.file.name}
                        ></CustomCheckbox>
                      </div>
                      <div className="flex items-center space-x-2">
                        <span className="text-xs bg-gray-200 px-2 py-1 rounded">
                          {fileItem.type}
                        </span>
                        {fileItem.filePath && (
                          <span className="text-xs bg-green-200 px-2 py-1 rounded">
                            Subido ‚úì
                          </span>
                        )}
                      </div>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-center py-4">
                  No hay archivos que coincidan con el filtro seleccionado
                </p>
              )}
            </div>

            <div className="mt-4 flex justify-between">
              <div>
                <span className="font-bold">
                  {getSelectedFiles().length} de {files.length} archivos
                  seleccionados
                </span>
              </div>
              <BrutalButton
                onClick={handleProcessFiles}
                disabled={getSelectedFiles().length === 0}
                variant="green"
              >
                Procesar Seleccionados
              </BrutalButton>
            </div>
          </div>
        )}

        {step === 3 && (
          <div className="text-center space-y-4">
            <h2 className="text-2xl font-bold">
              ¬°Archivos Listos para Procesamiento!
            </h2>
            <p>Has seleccionado {getSelectedFiles().length} archivos.</p>

            <div className="grid grid-cols-2 gap-4 mt-6">
              <ButtonLink href="/process/convert" variant="default" size="lg">
                <p className="text-xl">Convertir Archivos</p>
              </ButtonLink>
              <ButtonLink href="/process/analyze" variant="default" size="lg">
                <p className="text-xl">Analizar Contenido</p>
              </ButtonLink>
              <ButtonLink href="/process/share" variant="default" size="lg">
                <p className="text-xl">Compartir Archivos</p>
              </ButtonLink>
              <ButtonLink href="/process/merge" variant="default" size="lg">
                <p className="text-xl">Combinar Archivos</p>
              </ButtonLink>
            </div>

            <div className="mt-8">
              <BrutalButton variant="red" onClick={handleNewUpload}>
                Comenzar Nuevo Proceso
              </BrutalButton>
            </div>
          </div>
        )}
      </div>
      <div className="mt-4 flex justify-center">
        <ButtonLink href="/" variant="outline" size="lg">
          <p className="text-xl">Home</p>
        </ButtonLink>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ utils/

            üìÑ categorizerAPI.ts
            Path: app\utils/categorizerAPI.ts
            --------------------------------------------------
// src/lib/categorizerAPI.ts

import axios, { AxiosRequestConfig } from "axios";

// Definici√≥n de tipos base
export interface FileMetadata {
  original_name: string | undefined;
  id: string;
  fileName: string;
  fileType: string;
  filePath: string;
  fileSize: number;
  uploadDate: string;
  lastModified: string;
  tags: string[];
  categories: string[];
  description?: string;
  customFields?: Record<string, any>;
  embeddings?: boolean;
  processed?: boolean;
}

export interface GraphNode {
  id: string;
  type: string; // 'file', 'category', 'tag', 'concept', etc.
  name: string;
  metadata?: Record<string, any>;
}

export interface GraphConnection {
  source: string;
  target: string;
  type: string; // 'contains', 'related', 'similar', etc.
  weight: number;
  metadata?: Record<string, any>;
}

export interface GraphData {
  nodes: GraphNode[];
  connections: GraphConnection[];
}

export interface LLMChatMessage {
  role: "user" | "assistant" | "system";
  content: string;
}

export interface LLMChatResponse {
  message: LLMChatMessage;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  sources?: {
    filePath: string;
    fileName: string;
    relevance: number;
    snippet: string;
  }[];
}

export interface ProcessingOptions {
  extractText?: boolean;
  generateEmbeddings?: boolean;
  extractMetadata?: boolean;
  categorize?: boolean;
  summarize?: boolean;
  generateTags?: boolean;
  findConnections?: boolean;
}

export interface SearchParams {
  query: string;
  fileTypes?: string[];
  tags?: string[];
  categories?: string[];
  dateFrom?: string;
  dateTo?: string;
  limit?: number;
  offset?: number;
}

type ProcessLLMOptions = {
  extractAuthor: boolean;
  extractTitle: boolean;
  extractDescription: boolean;
  extractTags: boolean;
};

type ProcessLLMResult = {
  author?: string;
  title?: string;
  description?: string;
  tags?: string[];
  extractedText?: string;
};

type OCRResult = {
  text: string;
  confidence?: number;
};

// Clase principal para API del categorizador
class CategorizerAPI {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_CATEGORIZER_URL!;
    this.headers = {
      "Content-Type": "application/json",
    };
  }

  // Establecer token de autenticaci√≥n si es necesario
  setAuthToken(token: string) {
    this.headers["Authorization"] = `Bearer ${token}`;
  }

  // M√©todos relacionados con archivos
  // --------------------------------

  /**
   * Sube m√∫ltiples archivos al servidor
   * @param files Lista de archivos a subir
   * @param options Opciones de procesamiento inicial
   * @returns Informaci√≥n de los archivos subidos con rutas
   */
  async uploadFiles(
    files: File[],
    options?: ProcessingOptions
  ): Promise<FileMetadata[]> {
    const formData = new FormData();
    files.forEach((file) => {
      formData.append("files", file);
    });

    if (options) {
      formData.append("options", JSON.stringify(options));
    }

    try {
      const response = await axios.post(
        `${this.baseUrl}/files/upload/`,
        formData,
        {
          headers: {
            ...this.headers,
            "Content-Type": "multipart/form-data",
          },
        }
      );
      return response.data.files;
    } catch (error) {
      console.error("Error uploading files:", error);
      throw error;
    }
  }

  /**
   * Obtiene la lista de archivos de acuerdo a filtros
   * @param params Par√°metros de filtrado
   * @returns Lista de metadatos de archivos
   */
  async getFiles(params?: {
    types?: string[];
    processed?: boolean;
    limit?: number;
    offset?: number;
    search?: string;
  }): Promise<FileMetadata[]> {
    try {
      const response = await axios.get(`${this.baseUrl}/files`, {
        params,
        headers: this.headers,
      });
      return response.data.files;
    } catch (error) {
      console.error("Error getting files:", error);
      throw error;
    }
  }

  /**
   * Obtiene detalles de un archivo espec√≠fico
   * @param fileId ID del archivo
   * @returns Metadatos completos del archivo
   */
  async getFileDetails(fileId: string): Promise<FileMetadata> {
    try {
      const response = await axios.get(`${this.baseUrl}/files/${fileId}`, {
        headers: this.headers,
      });
      return response.data;
    } catch (error) {
      console.error(`Error getting file details for ${fileId}:`, error);
      throw error;
    }
  }

  /**
   * Elimina archivos del sistema
   * @param fileIds Array de IDs de archivos a eliminar
   * @returns Resultado de la operaci√≥n
   */
  async deleteFiles(
    fileIds: string[]
  ): Promise<{ success: boolean; deletedCount: number }> {
    try {
      const response = await axios.delete(`${this.baseUrl}/files`, {
        data: { fileIds },
        headers: this.headers,
      });
      return response.data;
    } catch (error) {
      console.error("Error deleting files:", error);
      throw error;
    }
  }

  // M√©todos de metadatos
  // --------------------------------

  /**
   * Actualiza los metadatos de un archivo
   * @param fileId ID del archivo
   * @param metadata Metadatos a actualizar
   * @returns Metadatos actualizados
   */
  async updateFileMetadata(
    fileId: string,
    metadata: Partial<FileMetadata>
  ): Promise<FileMetadata> {
    try {
      const response = await axios.put(
        `${this.baseUrl}/files/${fileId}/metadata`,
        metadata,
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error(`Error updating metadata for ${fileId}:`, error);
      throw error;
    }
  }

  /**
   * Actualiza metadatos de m√∫ltiples archivos en lote
   * @param updates Array de actualizaciones con ID y metadatos
   * @returns Resultado de la operaci√≥n
   */
  async batchUpdateMetadata(
    updates: Array<{ fileId: string; metadata: Partial<FileMetadata> }>
  ): Promise<{ success: boolean; updatedCount: number }> {
    try {
      const response = await axios.put(
        `${this.baseUrl}/files/metadata/batch`,
        { updates },
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error("Error batch updating metadata:", error);
      throw error;
    }
  }

  /**
   * Genera metadatos autom√°ticamente para archivos usando el LLM integrado
   * @param fileIds IDs de archivos para generar metadatos
   * @param options Opciones de generaci√≥n (tags, categor√≠as, descripci√≥n, etc)
   * @returns Metadatos generados
   */
  async generateMetadata(
    fileIds: string[],
    options: {
      generateTags?: boolean;
      generateCategories?: boolean;
      generateDescription?: boolean;
      extractExif?: boolean;
    }
  ): Promise<Array<{ fileId: string; metadata: Partial<FileMetadata> }>> {
    try {
      const response = await axios.post(
        `${this.baseUrl}/files/metadata/generate`,
        { fileIds, options },
        { headers: this.headers }
      );
      return response.data.results;
    } catch (error) {
      console.error("Error generating metadata:", error);
      throw error;
    }
  }

  // M√©todos de procesamiento
  // --------------------------------

  /**
   * Solicita el procesamiento de archivos (extracci√≥n de texto, generaci√≥n de embeddings, etc)
   * @param fileIds IDs de archivos a procesar
   * @param options Opciones de procesamiento
   * @returns Estado del procesamiento
   */
  async processFiles(
    fileIds: string[],
    options: ProcessingOptions
  ): Promise<{ success: boolean; jobId: string }> {
    try {
      const response = await axios.post(
        `${this.baseUrl}/files/process`,
        { fileIds, options },
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error("Error processing files:", error);
      throw error;
    }
  }

  // M√©todos de RAG y consulta
  // --------------------------------

  /**
   * Env√≠a una pregunta al LLM con contexto de los documentos indexados (RAG)
   * @param messages Historial de mensajes de la conversaci√≥n
   * @param options Opciones de consulta (archivos a incluir, etc)
   * @returns Respuesta del LLM con fuentes
   */
  async chatWithLLM(
    messages: LLMChatMessage[],
    options?: {
      includeSources?: boolean;
      maxSources?: number;
      restrictToFileIds?: string[];
      restrictToCategories?: string[];
      restrictToTags?: string[];
      temperature?: number;
    }
  ): Promise<LLMChatResponse> {
    try {
      const response = await axios.post(
        `${this.baseUrl}/rag/chat`,
        { messages, options },
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error("Error chatting with LLM:", error);
      throw error;
    }
  }

  /**
   * Realiza una b√∫squeda sem√°ntica en los archivos indexados
   * @param params Par√°metros de b√∫squeda
   * @returns Resultados de b√∫squeda ordenados por relevancia
   */
  async semanticSearch(params: SearchParams): Promise<{
    results: Array<{
      file: FileMetadata;
      relevance: number;
      snippet?: string;
    }>;
    totalResults: number;
  }> {
    try {
      const response = await axios.post(`${this.baseUrl}/rag/search`, params, {
        headers: this.headers,
      });
      return response.data;
    } catch (error) {
      console.error("Error performing semantic search:", error);
      throw error;
    }
  }

  // M√©todos de grafo de conocimiento
  // --------------------------------

  /**
   * Obtiene las conexiones de grafo para los elementos seleccionados
   * @param nodeIds IDs de nodos para incluir (archivos, categor√≠as, tags)
   * @param depth Profundidad de conexiones a explorar
   * @returns Datos del grafo con nodos y conexiones
   */
  async getGraphConnections(
    nodeIds: string[],
    depth: number = 1
  ): Promise<GraphData> {
    try {
      const response = await axios.post(
        `${this.baseUrl}/graph/connections`,
        { nodeIds, depth },
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error("Error getting graph connections:", error);
      throw error;
    }
  }

  /**
   * Encuentra nodos similares o relacionados a los proporcionados
   * @param nodeId ID del nodo de referencia
   * @param nodeType Tipo de nodos a recomendar
   * @param limit Cantidad m√°xima de recomendaciones
   * @returns Lista de nodos recomendados con puntuaci√≥n
   */
  async getRecommendedNodes(
    nodeId: string,
    nodeType: "file" | "tag" | "category",
    limit: number = 10
  ): Promise<Array<{ node: GraphNode; score: number }>> {
    try {
      const response = await axios.get(`${this.baseUrl}/graph/recommend`, {
        params: { nodeId, nodeType, limit },
        headers: this.headers,
      });
      return response.data.recommendations;
    } catch (error) {
      console.error("Error getting node recommendations:", error);
      throw error;
    }
  }

  /**
   * Crea una conexi√≥n manual entre dos nodos
   * @param connection Datos de la conexi√≥n a crear
   * @returns Conexi√≥n creada con ID
   */
  async createNodeConnection(
    connection: Omit<GraphConnection, "id">
  ): Promise<GraphConnection> {
    try {
      const response = await axios.post(
        `${this.baseUrl}/graph/connections/create`,
        connection,
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error("Error creating node connection:", error);
      throw error;
    }
  }

  // Administraci√≥n de categor√≠as y tags
  // --------------------------------

  /**
   * Obtiene todas las categor√≠as disponibles
   * @returns Lista de categor√≠as con metadatos
   */
  async getCategories(): Promise<
    Array<{ id: string; name: string; count: number }>
  > {
    try {
      const response = await axios.get(`${this.baseUrl}/categories`, {
        headers: this.headers,
      });
      return response.data.categories;
    } catch (error) {
      console.error("Error getting categories:", error);
      throw error;
    }
  }

  /**
   * Obtiene todos los tags disponibles
   * @returns Lista de tags con conteo
   */
  async getTags(): Promise<Array<{ id: string; name: string; count: number }>> {
    try {
      const response = await axios.get(`${this.baseUrl}/tags`, {
        headers: this.headers,
      });
      return response.data.tags;
    } catch (error) {
      console.error("Error getting tags:", error);
      throw error;
    }
  }

  /**
   * Crea una nueva categor√≠a
   * @param name Nombre de la categor√≠a
   * @param parentId ID de categor√≠a padre (opcional)
   * @returns Categor√≠a creada
   */
  async createCategory(
    name: string,
    parentId?: string
  ): Promise<{ id: string; name: string; parentId?: string }> {
    try {
      const response = await axios.post(
        `${this.baseUrl}/categories`,
        { name, parentId },
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error("Error creating category:", error);
      throw error;
    }
  }

  // Exportaci√≥n e importaci√≥n de datos
  // --------------------------------

  /**
   * Exporta toda la base de conocimiento o parte de ella
   * @param options Opciones de exportaci√≥n
   * @returns URL para descargar el archivo exportado
   */
  async exportKnowledgeBase(options?: {
    includeFiles?: boolean;
    includeMetadata?: boolean;
    includeGraph?: boolean;
    fileIds?: string[];
  }): Promise<{ exportUrl: string; jobId: string }> {
    try {
      const response = await axios.post(
        `${this.baseUrl}/export`,
        options || {},
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      console.error("Error exporting knowledge base:", error);
      throw error;
    }
  }

  /**
   * Importa datos a la base de conocimiento
   * @param importFile Archivo de importaci√≥n
   * @returns Resumen de la importaci√≥n
   */
  async importKnowledgeBase(importFile: File): Promise<{
    success: boolean;
    imported: {
      files: number;
      categories: number;
      tags: number;
      connections: number;
    };
    jobId: string;
  }> {
    const formData = new FormData();
    formData.append("importFile", importFile);

    try {
      const response = await axios.post(`${this.baseUrl}/import`, formData, {
        headers: {
          ...this.headers,
          "Content-Type": "multipart/form-data",
        },
      });
      return response.data;
    } catch (error) {
      console.error("Error importing knowledge base:", error);
      throw error;
    }
  }

  // Estad√≠sticas del sistema
  // --------------------------------

  /**
   * Obtiene estad√≠sticas generales del sistema
   * @returns Estad√≠sticas del sistema
   */
  async getSystemStats(): Promise<{
    totalFiles: number;
    totalCategories: number;
    totalTags: number;
    totalConnections: number;
    fileTypeDistribution: Record<string, number>;
    storageUsed: number;
    processingQueue: number;
  }> {
    try {
      const response = await axios.get(`${this.baseUrl}/stats`, {
        headers: this.headers,
      });
      return response.data;
    } catch (error) {
      console.error("Error getting system stats:", error);
      throw error;
    }
  }

  async processFileWithLLM(
    filePath: string,
    options: ProcessLLMOptions
  ): Promise<ProcessLLMResult> {
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/process/llm`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            filePath,
            options,
          }),
        }
      );

      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error en processFileWithLLM:", error);
      throw error;
    }
  }

  // Procesar imagen con OCR
  async processImageWithOCR(filePath: string): Promise<OCRResult> {
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/process/ocr`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            filePath,
          }),
        }
      );

      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error en processImageWithOCR:", error);
      throw error;
    }
  }

  // Guardar metadatos de m√∫ltiples archivos
  async saveFilesMetadata(metadata: any[]): Promise<void> {
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/metadata/save`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ metadata }),
        }
      );

      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
    } catch (error) {
      console.error("Error en saveFilesMetadata:", error);
      throw error;
    }
  }

  // Extraer contenido de un archivo JSON
  async extractJsonContent(filePath: string): Promise<any> {
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/process/json`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            filePath,
          }),
        }
      );

      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error en extractJsonContent:", error);
      throw error;
    }
  }
}

// Exportar una instancia por defecto
const categorizerAPI = new CategorizerAPI();
export default categorizerAPI;


            --------------------------------------------------

        üìÅ videos/

            üìÑ page.tsx
            Path: app\videos/page.tsx
            --------------------------------------------------
"use client";

import { useState, useCallback } from "react";
import { useDropzone } from "react-dropzone";
import { runFlow } from "../utils/langflowAPI";
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { BrutalInput } from "../components/InputComponent/InputComponent";
import BrutalDropDown from "../components/DropDownComponent/DropdownComponent";
import BrutalCheckbox from "../components/CheckBoxComponent/CheckBoxComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";

interface Metadata {
  author: string;
  description: string;
  date: string;
  title: string;
  tags: string[];
  themes: string[];
  [key: string]: string | string[];
}

export default function VideoUploadMultiStep() {
  // Control de pasos: 1 = subir video, 2 = metadatos, 3 = finalizado
  const [step, setStep] = useState<1 | 2 | 3>(1);

  // Estado para el video y la ruta que retorna el backend
  const [file, setFile] = useState<File | null>(null);
  const [filePath, setFilePath] = useState<string>("");

  // Estados de carga y generaci√≥n
  const [uploading, setUploading] = useState(false);
  const [generatingDescription, setGeneratingDescription] = useState(false);

  // Estado para metadatos y campos personalizados
  const [metadata, setMetadata] = useState<Metadata>({
    author: "",
    description: "",
    date: "",
    title: "",
    tags: [],
    themes: [],
  });
  const [customFields, setCustomFields] = useState<string[]>([]);

  // Estados locales para inputs de tags y themes (permiten espacios)
  const [tagsInput, setTagsInput] = useState<string>("");
  const [themesInput, setThemesInput] = useState<string>("");

  // Configuraci√≥n de Dropzone para videos
  const onDrop = useCallback((acceptedFiles: File[]) => {
    setFile(acceptedFiles[0]);
  }, []);
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { "video/*": [] },
  });

  // ------------------------------
  // Paso 1: Subir Video
  // ------------------------------
  const handleUpload = async () => {
    if (!file) return;
    setUploading(true);
    try {
      const formData = new FormData();
      formData.append("file", file);
      const uploadResponse = await runFlow({ image_path: "data" });
      const uploadData = await uploadResponse.json();
      console.log("Video subido:", uploadData);
      // Se espera que el endpoint retorne 'file_path'
      setFilePath(uploadData.file_path);
      setStep(2);
    } catch (error) {
      console.error("Error al subir el video:", error);
    } finally {
      setUploading(false);
    }
  };

  // ------------------------------
  // Paso 2: Configurar Metadatos y Generar Descripci√≥n
  // ------------------------------
  const handleMetadataChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setMetadata((prev) => ({ ...prev, [name]: value }));
  };

  const addCustomField = () => {
    const fieldName = prompt("Ingrese el nombre del nuevo campo:");
    if (fieldName && !customFields.includes(fieldName)) {
      setCustomFields((prev) => [...prev, fieldName]);
      setMetadata((prev) => ({ ...prev, [fieldName]: "" }));
    }
  };

  // Llamada para generar descripci√≥n, tags y themes a partir del video
  const handleGenerateDescription = async () => {
    if (!filePath) return;
    setGeneratingDescription(true);
    try {
      const response = await fetch("/api/generateVideoDescription", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ video_path: filePath }),
      });
      const data = await response.json();
      console.log("Respuesta de descripci√≥n:", data);
      setMetadata((prev) => ({
        ...prev,
        description: data.description || "",
        tags: data.tags || [],
        themes: data.themes || [],
      }));
      setTagsInput(data.tags ? data.tags.join(", ") : "");
      setThemesInput(data.themes ? data.themes.join(", ") : "");
    } catch (error) {
      console.error("Error al generar la descripci√≥n:", error);
    } finally {
      setGeneratingDescription(false);
    }
  };

  // Env√≠o final de metadatos y ruta del video
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const tagsArray = tagsInput
      .split(",")
      .map((item) => item.trim())
      .filter((item) => item);
    const themesArray = themesInput
      .split(",")
      .map((item) => item.trim())
      .filter((item) => item);
    const submissionData = {
      videoUrl: filePath,
      ...metadata,
      tags: tagsArray,
      themes: themesArray,
    };
    try {
      const backendResponse = await runFlow({ image_path: "data" });
      if (!backendResponse.ok) {
        throw new Error("Error al enviar los datos al backend");
      }
      console.log("Metadatos del video enviados correctamente");
      setStep(3);
    } catch (error) {
      console.error("Error en el env√≠o final:", error);
    }
  };

  // Reiniciar para subir otro video
  const handleNewVideo = () => {
    setFile(null);
    setFilePath("");
    setMetadata({
      author: "",
      description: "",
      date: "",
      title: "",
      tags: [],
      themes: [],
    });
    setTagsInput("");
    setThemesInput("");
    setCustomFields([]);
    setStep(1);
  };

  return (
    <div className="container mx-auto p-4 min-h-screen flex flex-col items-center justify-center bg-yellow-100">
      <TitleComponent title="Send Your Video" variant="neobrutalism" />
      <div className="max-w-xl mx-auto p-4 border-4 border-black bg-white rounded-lg space-y-6">
        {step === 1 && (
          <div>
            <h2 className="text-2xl font-bold mb-4">Paso 1: Subir Video</h2>
            <div
              {...getRootProps()}
              className={`p-6 border-4 border-black rounded-lg text-center cursor-pointer text-2xl ${
                isDragActive ? "bg-green-300" : "bg-blue-300"
              }`}
            >
              <input {...getInputProps()} />
              {file ? (
                <p className="text-2xl text-black font-bold">
                  Video seleccionado: {file.name}
                </p>
              ) : (
                <p className="text-lg font-bold">
                  Arrastra y suelta un video, o haz click para seleccionar
                </p>
              )}
            </div>
            <BrutalButton
              onClick={handleUpload}
              disabled={!file || uploading}
              variant="blue"
              className="mt-4"
            >
              {uploading ? "Subiendo..." : "Subir Video"}
            </BrutalButton>
          </div>
        )}

        {step === 2 && (
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="flex justify-between items-center mb-4">
              <BrutalButton
                onClick={() => setStep(1)}
                variant="gray"
                className="text-black"
              >
                Volver
              </BrutalButton>
              <h2 className="text-2xl font-bold">
                Paso 2: Metadatos del Video
              </h2>
            </div>
            <p className="mb-2">Video subido en: {filePath}</p>
            <BrutalInput
              type="text"
              name="author"
              value={metadata.author}
              onChange={handleMetadataChange}
              placeholder="Autor"
              className="w-full text-xl mb-2"
            />
            <BrutalInput
              type="text"
              name="title"
              value={metadata.title}
              onChange={handleMetadataChange}
              placeholder="T√≠tulo del video"
              className="w-full text-xl mb-2"
            />
            <BrutalInput
              type="date"
              name="date"
              value={metadata.date}
              onChange={handleMetadataChange}
              className="w-full text-xl mb-2"
            />
            <textarea
              name="description"
              value={metadata.description}
              onChange={handleMetadataChange}
              placeholder="Descripci√≥n (editable)"
              className="w-full p-4 border-4 border-black rounded-lg text-xl bg-orange-300 placeholder-black mb-2"
            />
            <BrutalInput
              type="text"
              name="tags"
              value={tagsInput}
              onChange={(e) => setTagsInput(e.target.value)}
              placeholder="Tags (separados por coma, espacios permitidos)"
              className="w-full text-xl mb-2"
            />
            <BrutalInput
              type="text"
              name="themes"
              value={themesInput}
              onChange={(e) => setThemesInput(e.target.value)}
              placeholder="Themes (separados por coma, espacios permitidos)"
              className="w-full text-xl mb-2"
            />

            {customFields.map((field) => (
              <BrutalInput
                key={field}
                type="text"
                name={field}
                value={metadata[field] as string}
                onChange={handleMetadataChange}
                placeholder={field}
                className="w-full text-xl bg-gray-200 mb-2"
              />
            ))}

            <BrutalButton variant="red" onClick={addCustomField}>
              A√±adir campo personalizado
            </BrutalButton>
            <div className="flex flex-col space-y-4">
              <BrutalButton
                type="button"
                onClick={handleGenerateDescription}
                disabled={generatingDescription || !filePath}
                variant="teal"
              >
                {generatingDescription ? "Generando..." : "Generar Descripci√≥n"}
              </BrutalButton>
              <BrutalButton type="submit" variant="blue">
                Enviar
              </BrutalButton>
            </div>
          </form>
        )}

        {step === 3 && (
          <div className="text-center space-y-4">
            <h2 className="text-2xl font-bold">¬°Proceso Finalizado!</h2>
            <p>Los metadatos del video han sido enviados correctamente.</p>
            <BrutalButton variant="green" onClick={handleNewVideo}>
              Subir otro video
            </BrutalButton>
          </div>
        )}
      </div>
      <div className="mt-4 flex justify-center">
        <ButtonLink href="/" variant="outline" size="lg">
          <p className="text-xl">Home</p>
        </ButtonLink>
      </div>
    </div>
  );
}


            --------------------------------------------------

        üìÅ visualizer/

            üìÑ page.tsx
            Path: app\visualizer/page.tsx
            --------------------------------------------------
"use client";

import React, { useRef, useEffect } from "react";
import * as d3 from "d3";
import BrutalButton from "../components/ButtonComponent/ButtonComponent";
import { TitleComponent } from "../components/TitleComponent/TtitleComponent";
import { ButtonLink } from "../components/ButtonLink/ButtonLink";

interface NodeDatum {
  id: string;
  group: number;
  info: string;
  x?: number;
  y?: number;
  fx?: number | null;
  fy?: number | null;
}

interface LinkDatum {
  source: string | NodeDatum;
  target: string | NodeDatum;
  value: number;
  info: string;
}

interface GraphData {
  nodes: NodeDatum[];
  links: LinkDatum[];
}

// Datos de ejemplo
const mockData: GraphData = {
  nodes: [
    { id: "1", group: 1, info: "Nodo 1 (Grupo 1)" },
    { id: "2", group: 2, info: "Nodo 2 (Grupo 2)" },
    { id: "3", group: 1, info: "Nodo 3 (Grupo 1)" },
    { id: "4", group: 3, info: "Nodo 4 (Grupo 3)" },
    { id: "5", group: 2, info: "Nodo 5 (Grupo 2)" },
  ],
  links: [
    { source: "1", target: "2", value: 1, info: "Relaci√≥n A" },
    { source: "2", target: "3", value: 2, info: "Relaci√≥n B" },
    { source: "3", target: "4", value: 1, info: "Relaci√≥n C" },
    { source: "2", target: "5", value: 3, info: "Relaci√≥n D" },
  ],
};

export default function GraphVisualization() {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    const width = 800;
    const height = 600;

    // Escala de colores
    const color = d3.scaleOrdinal(d3.schemeTableau10);

    // Clonar datos para evitar mutaciones
    const links: LinkDatum[] = mockData.links.map((d) => ({ ...d }));
    const nodes: NodeDatum[] = mockData.nodes.map((d) => ({ ...d }));

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    svg
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto; background: #fff");

    // Crear la simulaci√≥n de fuerza
    const simulation = d3
      .forceSimulation<NodeDatum>(nodes)
      .force(
        "link",
        d3
          .forceLink<NodeDatum, LinkDatum>(links)
          .id((d) => d.id)
          .distance(120)
      )
      .force("charge", d3.forceManyBody().strength(-200))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .on("tick", ticked);

    // Dibujar enlaces con estilo "neo-brutalista": gruesos y negros
    const link = svg
      .append("g")
      .selectAll("line")
      .data(links)
      .join("line")
      .attr("stroke", "#000")
      .attr("stroke-width", 4)
      .attr("stroke-dasharray", "4,2");

    // Texto para cada enlace
    const linkText = svg
      .append("g")
      .selectAll("text")
      .data(links)
      .join("text")
      .attr("text-anchor", "middle")
      .attr("font-size", 12)
      .attr("fill", "#000")
      .style("font-weight", "bold")
      .text((d) => d.info);

    // Dibujar nodos (c√≠rculos) con borde grueso
    const node = svg
      .append("g")
      .selectAll("circle")
      .data(nodes)
      .join("circle")
      .attr("r", 12)
      .attr("fill", (d) => color(d.group.toString()))
      .attr("stroke", "#000")
      .attr("stroke-width", 3);

    // Texto para cada nodo
    const nodeText = svg
      .append("g")
      .selectAll("text")
      .data(nodes)
      .join("text")
      .attr("text-anchor", "middle")
      .attr("dy", -18)
      .attr("font-size", 12)
      .attr("fill", "#000")
      .style("font-weight", "bold")
      .text((d) => d.info || d.id);

    // Arrastre de nodos
    (
      node as d3.Selection<SVGCircleElement, NodeDatum, SVGGElement, unknown>
    ).call(
      d3
        .drag<SVGCircleElement, NodeDatum>()
        .on("start", (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on("drag", (event, d) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on("end", (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        })
    );

    function ticked() {
      link
        .attr("x1", (d) => (d.source as NodeDatum).x!)
        .attr("y1", (d) => (d.source as NodeDatum).y!)
        .attr("x2", (d) => (d.target as NodeDatum).x!)
        .attr("y2", (d) => (d.target as NodeDatum).y!);

      linkText
        .attr(
          "x",
          (d) => ((d.source as NodeDatum).x! + (d.target as NodeDatum).x!) / 2
        )
        .attr(
          "y",
          (d) => ((d.source as NodeDatum).y! + (d.target as NodeDatum).y!) / 2
        );

      node.attr("cx", (d) => d.x!).attr("cy", (d) => d.y!);
      nodeText.attr("x", (d) => d.x!).attr("y", (d) => d.y! - 18);
    }

    return () => {
      simulation.stop();
    };
  }, []);

  // Ejemplo de funciones de men√∫ (puedes adaptarlas seg√∫n tu l√≥gica real)
  const handleReloadGraph = () => {
    // Ej: recargar o volver a ejecutar la simulaci√≥n
    window.location.reload();
  };

  const handleAddNode = () => {
    // L√≥gica para a√±adir un nodo en la DB
    alert("Funcionalidad 'Agregar Nodo' no implementada todav√≠a.");
  };

  const handleFilter = () => {
    // L√≥gica para filtrar nodos/relaciones
    alert("Funcionalidad 'Filtrar' no implementada todav√≠a.");
  };

  return (
    <div className="flex min-h-screen border-4 border-black bg-white">
      <div className="w-64 border-r-4 border-black p-4 bg-[#FFD6E8] -rotate-1 origin-top-left transform flex flex-col gap-4">
        <TitleComponent title="Graph Menu" variant="yellow" />
        <BrutalButton variant="blue" onClick={handleAddNode}>
          Agregar Nodo
        </BrutalButton>
        <BrutalButton variant="green" onClick={handleFilter}>
          Filtrar
        </BrutalButton>
        <BrutalButton variant="red" onClick={handleReloadGraph}>
          Recargar
        </BrutalButton>{" "}
        <ButtonLink href="/" variant="outline" size="lg">
          <p className="text-xl">Home</p>
        </ButtonLink>
      </div>
      <div className="flex-1 p-4 bg-[#FFFCD6] rotate-1 origin-top-left transform">
        <div className="border-4 border-black p-2 rounded-md bg-[#FFFFFF]">
          <svg ref={svgRef}></svg>
        </div>
      </div>
    </div>
  );
}


            --------------------------------------------------


## Resumen de Ejecuci√≥n
Archivos procesados: 18
Archivos omitidos: 13
Tama√±o m√°ximo permitido: 100.0 KB
Extensiones ignoradas: .zip, .swo, .webp, .swp, .md, .pyc, .gif, .png, .mp4, .jpg, .tar, .tmp, .mp3, .gz, .log, .jpeg, .svg, .db, .css, .ico, .mjs
Directorios ignorados: node_modules, .idea, .vercel, .next, __pycache__, .cache, staticfiles, venv, .vscode, public, build, .github, coverage, .git, env, out, migrations, media, dist, components
